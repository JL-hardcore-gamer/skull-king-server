diff --git a/src/Actions.ts b/src/Actions.ts
index c24e488..0b3e34a 100644
--- a/src/Actions.ts
+++ b/src/Actions.ts
@@ -259,8 +259,18 @@ export class OnCardReceivedCommand extends Command<
     /!\ TODO: beware of the Bloody Mary. Her versatility is not handled here!
   */
 
+  startNextTrick(round: Round, trick: Trick) {
+    const winner = trick.winner;
+
+    // v not useful I think v
+    round.firstPlayer = winner;
+
+    const nextID = trick.id + 1;
+    this.state.currentTrick = new Trick(nextID, winner);
+    round.remainingTricks -= 1;
+  }
+
   execute(obj: any) {
-    console.log('===== EXECUTE ===== ');
     const deck = createDeck();
     const card = deck[obj.cardId - 1]; // because cards ID start at 1 rather than 0
     const trick = this.state.currentTrick;
@@ -271,12 +281,19 @@ export class OnCardReceivedCommand extends Command<
     const round = this.state.game.remainingRounds[0];
     let suit = trick.suit;
 
-    console.log('JUST BEFORE REMOVED');
     this.removeCardFromPlayerHand(round, playerId, obj.cardId);
     this.addCardtoCardsPlayed(playerId, card);
     if (!suit) this.defineTrickSuit(card);
+
     if (this.trickHasEnded(playerOrder)) {
       this.computeWinner(suit, trick.cardsPlayed, playerOrder, round);
+      // start new trick unless no more remaining tricks
+      if (round.remainingTricks) {
+        this.startNextTrick(round, trick);
+      } else {
+        // compute round scores
+        // start new round
+      }
     } else {
       this.computeNextPlayer(playerId, playerOrder);
     }
diff --git a/src/Round.ts b/src/Round.ts
index fbc3eda..ba596fa 100644
--- a/src/Round.ts
+++ b/src/Round.ts
@@ -13,6 +13,7 @@ export class Round extends Schema {
   startingPlayer: number;
   // first player of the round, depends on the game order
 
+  // not useful I think
   @type('number')
   firstPlayer: number;
   // first player of the trick (except first trick), depends on the last trick winner
@@ -44,5 +45,9 @@ export class Round extends Schema {
     this.startingPlayer = startingPlayer;
     this.playersHand = playersHand;
     this.playersScore = playersScore;
+
+    // when we start a round, we automatically start a trick
+    // eg. at the start of round 3, there will be 2 tricks remaining after the current one 
+    this.remainingTricks = id - 1;
   }
 }
diff --git a/src/SkullKing.ts b/src/SkullKing.ts
index 8129a29..37027bd 100644
--- a/src/SkullKing.ts
+++ b/src/SkullKing.ts
@@ -79,16 +79,6 @@ export class SkullKing extends Room<State> {
     });
 
     this.onMessage('PLAY_CARD', (client, message) => {
-      // - check that card is from currentPlayer
-      // - remove card from player's hand
-      // - add card to Trick cardPlayed
-      // (with key player Id)
-      // - check if suit is undefined & define suit of Trick
-      // - update current player
-      // - check if trick is over?
-      // -- if it is, compute winner
-      // -- & go to next trick
-
       console.log('player array:', this.state.game.orderedPlayers);
       console.log('Current: ', this.state.currentTrick.currentPlayer);
 
@@ -97,7 +87,6 @@ export class SkullKing extends Room<State> {
         cardId: message.value,
       });
 
-      console.log(message.value);
       console.log(
         `${client.auth.nickname} a jou√© ${
           this.state.currentTrick.cardsPlayed[client.auth.ID].friendlyName
@@ -110,11 +99,6 @@ export class SkullKing extends Room<State> {
       console.log('Winner: ', winner);
 
       if (winner !== undefined) {
-        this.broadcast(
-          'TOP_MESSAGE',
-          `${this.state.players[winner].name} remporte le pli avec ${this.state.currentTrick.cardsPlayed[winner].friendlyName} !`
-        );
-
         this.broadcast(
           'TRICK_WINNER',
           `${this.state.players[winner].name} remporte le pli avec ${this.state.currentTrick.cardsPlayed[winner].friendlyName} !`
